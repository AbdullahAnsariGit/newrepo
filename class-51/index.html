<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- Done Topics -->
    <!-- <h1>Template literals</h1> -->
    <!-- <h1>Variable Scoping</h1> -->
    <!-- <h1>Arrow functions</h1> -->
    <!-- <h1>Ternary Operator</h1> -->

    <h1>Closure</h1>
    <p>Closure JavaScript me ek function ke andar dusre function ko access karne ki ability hai, chahe outer function
        execute ho chuka ho. Ye inner function apne lexical scope ke variables ko yaad rakhta hai.</p>

    <h2>Lexical Scope</h2>
    <p>Lexical scope JavaScript me ek rule hai jo define karta hai ki variables ko kaha se access kiya ja sakta hai. Ye
        scope us jagah par based hota hai jahan code likha gaya hai, na ki jahan se function call hota hai.</p>



    <h1>Destructuring</h1>
    <p> Ek tarika hai jo objects ya arrays ke elements ko asaani se alag variables me tod kar store karne ke liye use
        hota hai.</p>
    <h1>Default parameters</h1>


    <h1>Rest parameter</h1>
    <p>Ek syntax hota hai jo function parameters ko ek array me collect karne ke liye use hota hai.</p>

    <h1>Spread Operator</h1>
    <p>Syntax ek tarika hai jo objects ya arrays ke elements ko easily copy ya expand karne ka allow karta hai.</p>

    <h1>Enhanced object literals</h1>
    <p>Enhanced object literals JavaScript me object banane ka naya aur asaan tarika hai jo shorthand properties,
        methods, aur dynamic property names ko support karta hai.</p>
    <h2>1- Property Shorthand</h2>
    <h2>2- Method Shorthand</h2>
    <h2>3- Computed Property Names</h2>

    <h1>Array methods</h1>
    <h1>Callback</h1>
    <h1>Map</h1>
    <p>In JavaScript, a Map is a collection of key-value pairs where both keys and values can be of any data type.
        Unlike regular JavaScript objects, which only allow strings or symbols as keys, Map can use objects, functions,
        or primitives as keys.</p>
    <h2>Why use map</h2>
    <p>Map JavaScript ka ek built-in object hai jo key-value pairs ko store karta hai, jisme key kisi bhi type ka ho
        sakta hai (string, number, object, function, etc.), aur value kuch bhi ho sakta hai. Yani Map zyada flexible hai
        objects ke comparison mein isme builtin size dekhne ka bhi method h</p>
    <p>Map ek powerful object hai jisme aap key-value pairs ko efficiently manage kar sakte hain.
        Methods jese .set(), .get(), .has(), .delete(), .size aapko map ki operations ko efficiently perform karne mein
        madad karte hain.
        Aap Map ko object ke comparison mein zyada flexible aur performant paenge, especially jab aapko objects ko keys
        bana kar use karna ho.</p>

    <h1>Higher-order function</h1>
    <p>
        Higher-order function wo function hota hai jo dusre function ko argument ke roop mein accept karta ho, ya apne
        result ke roop mein ek function return karta ho.</p>


    <h1>Generators</h1>
    <p>JavaScript ke generator functions ek khaas tarah ke function hote hain jo execution ko pause aur resume karne ki
        ability dete hain. Matlab, aap ek function ko chalakar beech me rokh bhi sakte ho, aur phir jahan se roka tha
        wahi se dobara start kar sakte ho. Iska use tab hota hai jab hume lazmi nahi hota ke ek sath saara kaam ho,
        balki hume ek-ek step me values ya kaam lena hota hai.</p>

    <h2>How to create</h2>
    <p>Generator function ko banane ke liye function* ka use hota hai (matlab * lagana zaruri hai). Iske andar yield
        keyword ka use hota hai jo ek value ko return karta hai aur function ko pause kar deta hai.</p>


    <h1>Optional chaining</h1>
    <p>Optional Chaining (?.) in JavaScript is a feature that allows you to safely access deeply nested properties of an
        object without having to manually check if each property exists. If any part of the chain is null or undefined,
        it short-circuits and returns undefined instead of throwing an error.</p>

    <h1>Exponentiation Operator</h1>
    <p>The Exponentiation Operator (**) in JavaScript is used to raise a number to the power of another number. It is a
        shorthand way to calculate exponents, similar to using the Math.pow() function.</p>


    <h1>Modules</h1>
    <p>
        Modules in JavaScript are a way to organize and encapsulate code into reusable and maintainable pieces. They
        allow you to split your code into separate files or modules, making it easier to manage, debug, and share
        functionality across different parts of an application.
    </p>
    <h1>Generators</h1>
    <p>JavaScript ke generator functions ek khaas tarah ke function hote hain jo execution ko pause aur resume karne ki
        ability dete hain. Matlab, aap ek function ko chalakar beech me rokh bhi sakte ho, aur phir jahan se roka tha
        wahi se dobara start kar sakte ho. Iska use tab hota hai jab hume lazmi nahi hota ke ek sath saara kaam ho,
        balki hume ek-ek step me values ya kaam lena hota hai.</p>

    <h2>How to create</h2>
    <p>Generator function ko banane ke liye function* ka use hota hai (matlab * lagana zaruri hai). Iske andar yield
        keyword ka use hota hai jo ek value ko return karta hai aur function ko pause kar deta hai.</p>


    <h1>Optional chaining</h1>
    <p>Optional Chaining (?.) in JavaScript is a feature that allows you to safely access deeply nested properties of an
        object without having to manually check if each property exists. If any part of the chain is null or undefined,
        it short-circuits and returns undefined instead of throwing an error.</p>

    <h1>Exponentiation Operator</h1>
    <p>The Exponentiation Operator (**) in JavaScript is used to raise a number to the power of another number. It is a
        shorthand way to calculate exponents, similar to using the Math.pow() function.</p>


    <h1>Modules</h1>
    <h1>Class</h1>
    <p>
        Modules in JavaScript are a way to organize and encapsulate code into reusable and maintainable pieces. They
        allow you to split your code into separate files or modules, making it easier to manage, debug, and share
        functionality across different parts of an application.
    </p>
    <h1>Iterators & For..of</h1>
    <p>
        The for...of loop in JavaScript is used to iterate over iterable objects like arrays, strings, Maps, Sets. It
        provides a clean syntax to loop through the values of an iterable.</p>
    <h1>Promises</h1>
    <p>JavaScript mein Promise ek aise object ko kaha jata hai jo kisi asynchronous operation ka result represent karta
        hai. Matlab, jab aap koi kaam karte hain jo thoda time leta hai, toh uska result aapko baad mein milega. Promise
        se aap yeh result "promise" karte hain.</p>
    <h2>Promise ka basic structure:</h2>
    <p>Ek promise 3 states mein ho sakta hai:
        Pending: Jab promise ka kaam abhi ho raha ho.
        Resolved/ Fulfilled: Jab promise ka kaam successfully ho jaye.
        Rejected: Jab promise ka kaam fail ho jaye.</p>

    <h3>Promise ka kaam kaise karta hai?</h3>
    <p>Jab aap new Promise create karte ho, toh aap do functions pass karte ho:

        resolve: Agar kaam sahi tarah se ho jaye, toh aap resolve ko call karte hain.
        reject: Agar kuch galat ho, toh aap reject ko call karte hain.
        Phir, aap .then() aur .catch() methods se result handle karte hain:

        .then(): Jab promise resolve ho jaye, toh .then() ka callback function execute hota hai.
        .catch(): Jab promise reject ho jaye, toh .catch() ka callback function execute hota hai.
    </p>
    <h4> Why Promises</h4>
    <p>Promise ko use karne ka main reason yeh hai ke asynchronous operations ko handle karne ka ek structured aur
        readable tareeqa milta hai. Aaj kal JavaScript applications me jo bhi operations time leta hai (jaise data
        fetching, file reading, user authentication, etc.), unhe asynchronously process kiya jata hai. Jab hum
        asynchronous operations ko handle karte hain, tab callbacks ka use karna complex ho sakta hai, aur code ka flow
        samajhna mushkil ho jata hai.</p>
    <p>Cleaner Code,Error Handling,Avoid Callback Hell</p>
    <h2>Promises all</h2>
    <p>method multiple promises ko ek sath handle karta hai. Yeh method ek array of promises accept karta hai aur jab
        saare promises resolve ho jate hain, toh ek array of results return karta hai. Agar koi bhi promise reject hota
        hai, toh Promise.all() usse reject kar deta hai.</p>
    <h2>Promises race</h2>
    <p>method multiple promises me se pehla resolve ya reject hone wala promise return karta hai. Yeh method ek array of
        promises ko accept karta hai, aur jo promise pehla resolve ya reject hota hai, uska result milta hai.</p>
    <h2>Promises allSettled</h2>
    <p>method ek array of promises ko accept karta hai aur us array ke saare promises complete hone par ek array return
        karta hai, chahe promises resolve ho ya reject. Yeh useful hota hai jab aapko har promise ke result ko dekhna
        ho, regardless of whether it was resolved or rejected.</p>

    <h2>Promises Any</h2>
    <p>method ek array of promises ko accept karta hai aur sabse pehle jo promise resolve hota hai, uska result return
        karta hai. Agar saare promises reject ho jate hain, toh yeh ek aggregate error throw karega.</p>
    <h3>Summary of Promise Methods:
        then(): Success handling for a resolved promise.
        catch(): Error handling for a rejected promise.
        finally(): Runs after then() or catch(), irrespective of the outcome.
        all(): Waits for all promises to resolve.
        race(): Resolves as soon as one promise resolves or rejects.
        allSettled(): Waits for all promises to settle (either resolve or reject).
        any(): Resolves as soon as any one promise resolves.</h3>


    <h1>Fetch</h1>
    <p>JavaScript ka fetch() ek modern tariqa hai jo hum web se data lene ya server par bhejne ke liye use karte hain.
        Yeh purane XMLHttpRequest ka badal hai aur Promises ke sath kaam karta hai, jo code ko simple aur samajhne me
        easy banata hai.</p>

    <h2>Fetch ka kam</h2>
    <p>fetch() ek HTTP request karta hai (jaise API se data lena) aur ek Promise return karta hai. Jab data milta hai ya
        koi error hoti hai, toh hum then aur catch ka use karke response handle karte hain.
    </p>
    <h1>GET (Retrieve data)</h1>
    <p>Use Case: Data ko server se retrieve (fetch) karna.
        Description: Jab aapko server se koi data chahiye hota hai (jaise weather information, product list, user
        profile, etc.), tab aap GET request use karte hain.
        Example: Fetch weather data, get user details, etc.
        Body: GET request me body nahi hoti. Hum query parameters ke through data bhejte hain.</p>

    <h1>POST (Create data)</h1>
    <p>Use Case: Server pe new data create karna.
        Description: Jab aapko server pe naya data bhejna ho (jaise user signup karna, new blog post banana, form submit
        karna, etc.), tab aap POST request use karte hain.
        Body: POST request me aap data ko body me bhejte hain.</p>


    <h1>PUT (Update data)
    </h1>

    <p>Use Case: Server pe existing data ko completely update karna.
        Description: Jab aapko kisi resource (data) ko completely update karna ho, tab aap PUT request use karte hain.
        Yeh purane data ko replace karta hai.
        Example: User profile update karna, kisi product ki details ko update karna, etc.
        Body: PUT request me updated data ko body me bheja jata hai.</p>


    <h1>DELETE (Delete data)</h1>
    <p>Use Case: Server se data delete karna.
        Description: Jab aapko server se koi data delete karna ho (jaise user ko delete karna, post ko delete karna,
        etc.), tab aap DELETE request use karte hain.
        Example: User account ko delete karna, kisi post ko delete karna, etc.
        Body: DELETE request me usually body nahi hoti, bas URL ke through resource specify kiya jata hai.</p>

    <h1>PATCH (Partial update)</h1>
    <p>Use Case: Server pe data ka partial update karna.
        Description: Jab aapko kisi resource ko partial update karna ho (kuch specific fields hi update karni ho), tab
        aap PATCH request use karte hain. Yeh PUT se thoda different hota hai, kyunki PUT puri resource ko replace karta
        hai, jabki PATCH sirf specified fields ko update karta hai.
        Example: User ka sirf email update karna, kisi product ka price update karna, etc.
        Body: PATCH request me sirf woh fields bheje jaate hain jo update karni hoti hain.</p>
    <script type="module" src="api.js"></script>
</body>

</html>